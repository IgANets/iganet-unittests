/**
   @file pyiganet/pybspline@GEODIM@d.cxx

   @brief PyIgANet multivariate B-splines

   @author Matthias Moller

   @copyright This file is part of the IgANet project

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

#include <pybind11/pybind11.h>
#include <pybind11/cast.h>
#include <pybind11/stl.h>
#include <pybind11_json/pybind11_json.hpp>
#include <torch/extension.h>

#include <boost/preprocessor/seq/for_each.hpp>

#include <pyconfig.hpp>

#include <bspline.hpp>

namespace py = pybind11;

void init_UniformBSpline@SUFFIX@(py::module_ &m) {
  py::class_<iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>>(m, "UniformBSpline@SUFFIX@")
    
    // Constructor
    .def(py::init<
         std::array<int64_t,
         static_cast<size_t>(iganet::UniformBSpline<pyiganet::real_t,
         @GEODIM@, @DEGREES@>::parDim())>,
         enum iganet::init>(),
         py::arg("ncoeffs"),
         py::arg("init") = iganet::init::greville,
         "Creates a uniform B-Spline object")

    // Static getters
    .def_static("parDim",
                &iganet::UniformBSpline<pyiganet::real_t,
                @GEODIM@, @DEGREES@>::parDim,
                "Returns the parametric dimension")
    .def_static("geoDim",
                &iganet::UniformBSpline<pyiganet::real_t,
                @GEODIM@, @DEGREES@>::geoDim,
                "Returns the geometric dimension")
    .def_static("degrees",
                &iganet::UniformBSpline<pyiganet::real_t,
                @GEODIM@, @DEGREES@>::degrees,
                "Returns the vector of polynomial degrees of all parametric dimensions")
    .def_static("degree",
                &iganet::UniformBSpline<pyiganet::real_t,
                @GEODIM@, @DEGREES@>::degree,
                "Returns the polynomial degree of a specific parametric dimension")

    // Knots
    .def("knots",
         py::overload_cast<>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::knots),
         "Returns a non-constant reference to the array of knot vectors")
    .def("knots",
         py::overload_cast<>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::knots,
          py::const_),
         "Returns a constant reference to the array of knot vectors")
    .def("knots",
         py::overload_cast<iganet::short_t>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::knots),
         "Returns a non-constant reference to the knot vector in the i-th dimension")
    .def("knots",
         py::overload_cast<iganet::short_t>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::knots,
          py::const_),
         "Returns a constant reference to the knot vector in the i-th dimension")

    // Number of knots
    .def("nknots",
         py::overload_cast<>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::nknots,
          py::const_),
         "Returns a constant reference to the array of knot vector dimensions")
    .def("knots",
         py::overload_cast<iganet::short_t>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::nknots,
          py::const_),
         "Returns the dimension of the knot vector in the i-th dimension")

    // Coefficients
    .def("coeffs",
         py::overload_cast<>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::coeffs),
         "Returns a non-constant reference to the array of coefficient vectors")
    .def("coeffs",
         py::overload_cast<>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::coeffs,
          py::const_),
         "Returns a constant reference to the array of coefficient vectors")
    .def("coeffs",
         py::overload_cast<iganet::short_t>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::coeffs),
         "Returns a non-constant reference to the coefficient vector in the i-th dimension")
    .def("coeffs",
         py::overload_cast<iganet::short_t>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::coeffs,
          py::const_),
         "Returns a constant reference to the coefficient vector in the i-th dimension")

    // Total number of coefficients
    .def("ncumcoeefs",
         &iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::ncumcoeffs,
         "Returns the total number of coefficients")
    
    // Number of coefficients
    .def("ncoeffs",
         py::overload_cast<>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::ncoeffs,
          py::const_),
         "Returns the coefficient vector dimensions as array")
    .def("ncoeffs",
         py::overload_cast<iganet::short_t>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::coeffs,
          py::const_),
         "Returns the number of coefficients in the i-th direction")

    // Coefficients as a single tensor
    .def("as_tensor",
         &iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::as_tensor,
         "Returns all coefficients as a single tensor")
    
    // Coefficients from a single tensor
    .def("from_tensor",
         &iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::from_tensor,
         "Sets all coefficients from a single tensor")
    
    // Greville points
    .def("greville",
         &iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::greville,
         py::arg("interior") = false,
         "Returns the Greville abscissae")

    // Evaluate B-splines from precomputed quantities
    .def("eval_from_precomputed",
         py::overload_cast<const torch::Tensor&, const torch::Tensor&, int64_t, torch::IntArrayRef>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::eval_from_precomputed,
          py::const_),
         "Returns the value of the B-spline object in the points xi")
    .def("eval_from_precomputed",
         py::overload_cast<const iganet::utils::TensorArray1&, const torch::Tensor&, int64_t, torch::IntArrayRef>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::eval_from_precomputed,
          py::const_),
         "Returns the value of the B-spline object in the points xi")
    .def("eval_from_precomputed",
         py::overload_cast<const iganet::utils::TensorArray2&, const torch::Tensor&, int64_t, torch::IntArrayRef>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::eval_from_precomputed,
          py::const_),
         "Returns the value of the B-spline object in the points xi")
    .def("eval_from_precomputed",
         py::overload_cast<const iganet::utils::TensorArray3&, const torch::Tensor&, int64_t, torch::IntArrayRef>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::eval_from_precomputed,
          py::const_),
         "Returns the value of the B-spline object in the points xi")
    .def("eval_from_precomputed",
         py::overload_cast<const iganet::utils::TensorArray4&, const torch::Tensor&, int64_t, torch::IntArrayRef>
         (&iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::eval_from_precomputed,
          py::const_),
         "Returns the value of the B-spline object in the points xi")

    // Evaluate B-splines
#define SEQ (func)(dx1)
    
    .def("eval",
         [](const iganet::UniformBSpline<pyiganet::real_t,@GEODIM@, @DEGREES@>& self,
            const torch::Tensor& xi,
            const enum iganet::deriv deriv)
         {          
           switch (deriv) {
             
#define    MACRO(r, data, elem)                                    \
             case (iganet::deriv::elem):                           \
               return self.eval<iganet::deriv::elem>(xi);
             
             BOOST_PP_SEQ_FOR_EACH(MACRO, _, SEQ)
#undef     MACRO
               
           default:
               throw std::runtime_error("Unsupported derivative");
           }
         },
         py::arg("xi"),
         py::arg("deriv") = iganet::deriv::func,
         "Returns the value of the B-spline object or its derivative in the points xi")

    .def("eval",
         [](const iganet::UniformBSpline<pyiganet::real_t,@GEODIM@, @DEGREES@>& self,
            const std::array<torch::Tensor,
            iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::parDim()>& xi,
            const enum iganet::deriv deriv)         
         {          
           switch (deriv) {
             
#define    MACRO(r, data, elem)                                    \
             case (iganet::deriv::elem):                           \
               return self.eval<iganet::deriv::elem>(xi);
             
             BOOST_PP_SEQ_FOR_EACH(MACRO, _, SEQ)
#undef     MACRO
               
           default:
               throw std::runtime_error("Unsupported derivative");
           }
         },
         py::arg("xi"),
         py::arg("deriv") = iganet::deriv::func,
         "Returns the value of the B-spline object or its derivative in the points xi")

    .def("eval",
         [](const iganet::UniformBSpline<pyiganet::real_t,@GEODIM@, @DEGREES@>& self,
            const std::array<torch::Tensor,
            iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::parDim()>& xi,
            const std::array<torch::Tensor,
            iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::parDim()>& indices,
            const enum iganet::deriv deriv)         
         {          
           switch (deriv) {
             
#define    MACRO(r, data, elem)                                     \
             case (iganet::deriv::elem):                            \
               return self.eval<iganet::deriv::elem>(xi, indices);
             
             BOOST_PP_SEQ_FOR_EACH(MACRO, _, SEQ)
#undef     MACRO
               
           default:
               throw std::runtime_error("Unsupported derivative");
           }
         },
         py::arg("xi"),
         py::arg("indices"),
         py::arg("deriv") = iganet::deriv::func,
         "Returns the value of the B-spline object or its derivative in the points xi")
    
    .def("eval",
         [](const iganet::UniformBSpline<pyiganet::real_t,@GEODIM@, @DEGREES@>& self,
            const std::array<torch::Tensor,
            iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::parDim()>& xi,
            const std::array<torch::Tensor,
            iganet::UniformBSpline<pyiganet::real_t, @GEODIM@, @DEGREES@>::parDim()>& indices,
            const torch::Tensor& coeff_indices,
            const enum iganet::deriv deriv)         
         {          
           switch (deriv) {
             
#define    MACRO(r, data, elem)                                         \
             case (iganet::deriv::elem):                                \
               return self.eval<iganet::deriv::elem>(xi, indices, coeff_indices);
             
             BOOST_PP_SEQ_FOR_EACH(MACRO, _, SEQ)
#undef     MACRO
               
           default:
               throw std::runtime_error("Unsupported derivative");
           }
         },
         py::arg("xi"),
         py::arg("indices"),
         py::arg("coeff_indices"),
         py::arg("deriv") = iganet::deriv::func,
         "Returns the value of the B-spline object or its derivative in the points xi")
    ;
}
